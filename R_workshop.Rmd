---
title: "Introduction to R"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: true
    toc_depth: 3
    number_sections: true
    theme: cosmo
author: "Isabelle Laforest-Lapointe, Amy Heim, Sophie Boutin, Jonathan Rondeau-Leclaire"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This tutorial was created for a 3-day free R introduction workshop organized by the [Laforest-Lapointe Lab](https://www.laforestlab.com/) at Universit√© de Sherbrooke on May 12th-14th.

# The Basics (Monday)

** Show how to import a "perfect" dataset*
```{r}
assay <- read.table("data/assay.txt", header = TRUE)
```

## Data classes

Objects and object components (e.g., data frame variables) always have a class. This class gives you a hint on how it will behave. You can check the class of any object this way:

```{r data class}
class(assay) # class of the object assay
str(assay) # class of each element of assay
class(assay$CFU) # class of a specific element of assay
```

There exist many classes, but a few are much more common than others. In the above example with `str()`, we can see two other classes, namely `num` for numeric vectors and `factor`, which is a special (composite) class for categorical data. Other common classes are `character` (chr), `integer` (int), `character` (chr) and `logical` (logi). 

For convenience, it's always good to have character columns as factor if they represent categorical data. 

```{r data class 2}
assay$Antibiotic <- as.factor(assay$Antibiotic)
str(assay$Antibiotic)
```

We can also see a composite class, `data.frame`. These are used for more complex objects, usually with two dimensions. Other composite classes include `matrix`, which are similar to data frames (the difference between these two is that data frames can contain elements of various classes). There are also `list` and `array`, which won't be covered in this course.

## Data overview

In any project, a first step should always be to look at your data as it appears in R. Many functions exist to help you do that. `summary()` will summarise variables in a class-dependent manner: numeric variables get a numeric summary (median, range, etc.), factors and logical get a count per category, and characters get a overview of the first values.

```{r summary}
summary(assay)
```

Other useful functions are `head()`, which shows the first rows of an object, and `View()`, which opens shows the object in a formatted manner, a bit like an excel sheet.

```{r head}
head(assay)
```

Other useful checks are `dim()` or `length()`, especially when playing with functions that modify our objects: 

```{r dim}
dim(assay) # shows the dimensions of matrices and data frames
ncol(assay) # number of columns
colnames(assay) # column (variable) names
length(assay$OD) # shows the length of vectors
```

## Basic operations

R can be used to operate on values in pretty much any way imaginable, from very simple things like calculating the mean to more complex things like removing certain characters from every values in a data frame variable.

There are a few basic functions worth knowing, as they can come in handy in many different situations. The very basic one is `c()` which is used to combine its arguments into a vector. If all arguments are numeric, the vector will be numeric. If they is at least one string (using `"double quotes"`), it will be a character vector.

Most mathematical operations are available as functions :
```{r math ops}
some_numbers <- head(assay$CFU)
sum(some_numbers) # Sum the values of a numeric vector
sqrt(some_numbers) # square root of each value
sum(some_numbers)/length(some_numbers) # compute the mean "manually"
mean(some_numbers) # compute the mean using a specific function
median(some_numbers)
sd(some_numbers) # compute the standard deviation
min(some_numbers) # find the minimum
```

Operations can also be done between columns of a data frame. In the following, we multiply two columns together and add the resulting vector as a new column on the same dataset using the `<-` (assignment) operator.
```{r}
vector_mutiplication <- assay$CFU * assay$OD
assay$new_column <- vector_mutiplication # add as a column
assay[['new_column']] <- vector_mutiplication # equivalent
summary(assay) 
```

### Loops

Loops are very useful, as they help us do similar operations multiple times while writing them only once. Let's say there you would like to multiply three columns of your dataframe by 1000. If your data was a numeric matrix, you could simply multiply the matrix object by 1000, e.g. `new_matrix = old_matrix*1000`. But we usually work with data frames, because our data contains various types of variables. Thus, columns may be characters or factors, which obviously cannot be multiplied. So we want to selectively multiply certain columns :

```{r}
my_data_frame <- assay # we just copy the df not to overwrite it
my_data_frame$CFU <- my_data_frame$CFU*1000
my_data_frame$OD <- my_data_frame$OD*1000
my_data_frame$new_column <- my_data_frame$new_column*1000
```

and so on for every variable. Using a loop, it would look like this:
```{r}
for (i in c('OD', 'CFU', 'new_column')) { # define what to iterate on
  my_data_frame[[i]] <- my_data_frame[[i]]*1000
}
summary(my_data_frame)
```
It may not be useful for such a simple operation on only a few columns, but you can imagine how much time would be saved if the operations you do are more complex and need to be applied to multiple columns. Moreover, if you realise you need to multiply by 100 instead, you only have to change in one place, reducing the risk of syntax error.


### R as a calculator

You can also straight up use R as you would a calculator. Let's find the area of a single slice of a 14" pizza cut in 8, then format the result to be more "readable" :

```{r}
slice_area <- (pi*(14/2)^2)/4
slice_area_formatted <- round(slice_area, 2)
paste('The slice of a 14 inches pizza cut in 8 will have a surface of', slice_area_formatted, "square inches.")
```

Notice that we've created many objects to do this. We could just as well have done a single-liner that only prints the result to our console:
```{r}
paste('The slice of a 14 inches pizza cut in 8 will have a surface of', round((pi*(14/2)^2)/4, 2), "square inches.")
```
but it's up to you to decide how explicit you want your code to be. More explicit code is more readable, but requires more steps to be written out. It's all about balance.

You can also use R as a random number generator. The simplest way is using the uniform distribution, `runif()`, which draws `n` observations between specified values, and all values have an equal chance of being drawn.

```{r}
a_vector_of_values <- runif(n = 10, min = 0, max = 100)
a_vector_of_values
sort(a_vector_of_values)
```
You can draw from the normal distribution too, by specifying the mean and sd :

```{r}
a_normal_draw <- rnorm(n = 100, mean = 0, sd = 1)
head(a_normal_draw)
hist(a_normal_draw)
```

## Hands on session 1
#### Create a new script for your project
#### Import your data
#### Explore it
#### Format your data (categorical data as factors)
#### Subset, compute group means and sd
#### Make a histogram of a numeric variable
#### Make a dot plot with two variables (at least one numeric)
#### Ask us how to do what you want to do !

# Plots with ggplot (Tuesday)

We work with a real dataset where tomato plants have been infected (or not) with a pathogen. We want to look at the proportion of leaf area affected by chlorosis and compare it between the infected and control groups. 

## Objective
Plot the proportion of plant leaf covered by chlorosis with mean and standard devitions by replicate, in a way that will allow us to compare the two groups (infected and not infected) across the two treatments (mock of treated).

Two packages are required here, make sure you have installed them:
```{r}
# install.packages('tidyverse') # super-package that includes ggplot
# install.packages('openxlsx') # to parse excel files
```

## Preparing the data
```{r}
library(openxlsx)
tomato <- read.xlsx('data/Rocio_tomato_infection.xlsx')
str(tomato)

```

We have two character columns, which would be preferable to convert to factors. I have intentionnally introduced a typographic error in one of these character columns; factors will help us spot them quickly.
```{r}
tomato$Treatement <- as.factor(tomato$Treatement)
tomato$Infection <- as.factor(tomato$Infection)
tomato$rep <- as.factor(tomato$rep)
summary(tomato)
```

That's one way to do it. But there is a different syntax we can use that comes from the `tidyverse` superpackage. It uses the pipe operator `%>%`, which you can generate by using the `shift+cmd+m` keyboard combination (or `shift+ctrl+m` on Windows). To familiarise yourself with it, let's do the same thing as above using this syntax:

```{r}
library(tidyverse)
library(magrittr)

tomato <- tomato %>% 
  mutate(Treatement = as.factor(Treatement),
         Infection = as.factor(Infection),
         rep = as.factor(rep))
summary(tomato)
```

It may not seem like we gained much in terms of amount of code to write. But consider the following things we might want to do as well: 

1. The `Treatement` column name has an extra `e` in it, it should be `Treatment`
2. There is a typo in one of the Infection values we want to correct
3. We want to compute the proportion of the total area that is chlorotic

We can do all of this in a single piped command, without needing to rewrite `tomato$columnName <- ...` every time. Let's do all these three things, starting again from the raw data.

```{r}

tomato <- read.xlsx('data/Rocio_tomato_infection.xlsx') %>% 
  rename(Treatment = Treatement) %>% 
  mutate(
    Treatment = as.factor(Treatment), 
    rep = as.factor(rep),
    prop_chlorosis = 100*chlorotic.area/total.area,
    Infection = as.factor(
      case_when(
        Infection == "pathogn" ~ "pathogen",
        TRUE ~ Infection
        ))
    )

summary(tomato)
dim(tomato)
```

## Preparing your data

### The tidyverse syntax

### Creating and modifying variables

### Basic string manipulation

### Pivoting tables

### 

```{r }

```

# Stats in R (Wednesday)